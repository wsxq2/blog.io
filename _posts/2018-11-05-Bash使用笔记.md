---
tags: [Bash,TODO]
last_modified_time: 2019-11-21 11:39:46 +0800
---

关于 Shell 的系统学习可参考这个网站：[The Linux Command Line 中文版](https://www.kancloud.cn/thinkphp/linux-command-line/39431)

<p id="markdown-toc"></p>
<!-- vim-markdown-toc GFM -->

* [获取命令帮助](#获取命令帮助)
  * [`help`](#help)
  * [`--help`](#--help)
  * [`man`](#man)
  * [`info`](#info)
* [bash 自动补全](#bash-自动补全)
  * [使用包管理器安装](#使用包管理器安装)
  * [从源码安装](#从源码安装)
  * [调试](#调试)
  * [bash 加载配置文件的顺序](#bash-加载配置文件的顺序)
* [Expansion](#expansion)
* [Readline](#readline)
* [字符串](#字符串)
  * [拼接字符串](#拼接字符串)
    * [使用 `""`](#使用-)
    * [使用 `+=`](#使用--1)
    * [使用 `printf`](#使用-printf)
  * [字符串匹配通配符](#字符串匹配通配符)
    * [`=`](#)
    * [`case..in..`](#casein)
  * [字符串匹配正则表达式](#字符串匹配正则表达式)
    * [`=~`](#-1)
    * [`expr match`](#expr-match)
* [算术运算](#算术运算)
  * [整数运算](#整数运算)
    * [`$(())`](#-2)
    * [`expr`](#expr)
  * [浮点运算](#浮点运算)
    * [`bc`](#bc)
    * [`awk`](#awk)
* [输入输出（IO）](#输入输出io)
  * [从文件或`stdin`中读取输入](#从文件或stdin中读取输入)
  * [输入 ASCII 特殊字符](#输入-ascii-特殊字符)
    * [使用`echo`或`printf`](#使用echo或printf)
    * [使用`python`](#使用python)
    * [使用重定向`<`](#使用重定向)
    * [直接输入](#直接输入)
* [路径相关](#路径相关)
  * [转换相对路径为绝对路径](#转换相对路径为绝对路径)
    * [`$PWD`](#pwd)
    * [`realpath`](#realpath)
  * [`dirname && basename`](#dirname--basename)
* [进制转换](#进制转换)
  * [any base to decimal?](#any-base-to-decimal)
  * [hex number to binary string?](#hex-number-to-binary-string)
* [管道](#管道)
  * [grep through `|` can't get stderr content?](#grep-through--cant-get-stderr-content)
* [捕获信号](#捕获信号)
  * [响应`ctrl+c`](#响应ctrlc)
* [自定义环境](#自定义环境)
  * [列出所有自定义函数？](#列出所有自定义函数)
  * [列出所有自定义变量？](#列出所有自定义变量)
* [遇到过的问题](#遇到过的问题)
  * [转换 Windows 风格的换行符为 Linux 风格](#转换-windows-风格的换行符为-linux-风格)
    * [`vim`](#vim)
    * [`dos2unix`](#dos2unix)
    * [`tr`](#tr)
    * [`sed`](#sed)
  * [将 ls 的输出赋值给 Arrays 变量](#将-ls-的输出赋值给-arrays-变量)
* [实践记录](#实践记录)
  * [处理缩略语](#处理缩略语)
    * [使用`grep`](#使用grep)
    * [使用`case..in..`](#使用casein)
    * [使用`=~`](#使用)
    * [使用`=`](#使用-1)
  * [将 Windows 格式的文本文件转换为 Linux 格式](#将-windows-格式的文本文件转换为-linux-格式)
  * [dream 项目中的需求](#dream-项目中的需求)
* [链接](#链接)

<!-- vim-markdown-toc -->

## 获取命令帮助
三个主要的方法：`COMMAND --help`, `man COMMAND`, `info COMMAND`。且文档详细程度：`info`>`man`>`--help`。当然，个别命令可能详细程度相同

以上是针对普通命令或者叫做外部命令，对于 Shell（如 Bash） 内置命令，应使用`help COMMAND`来获取帮助

### `help`
该命令是 Shell 内置命令，用于获取 Shell（如 Bash） 内置命令的帮助，如：
```
help
help ulimit
help for
help if
help [[
help case
help while
...
```

### `--help`
下面以`flex --help`为例，详细说明如何使用`--help`。

`flex --help`的输出如下：
<pre>
Usage: flex [OPTIONS] [FILE]...
Generates programs that perform pattern-matching on text.

Table Compression:
  -Ca, --align      trade off larger tables for better memory alignment
  -Ce, --ecs        construct equivalence classes
  -Cf               do not compress tables; use -f representation
  -CF               do not compress tables; use -F representation
  -Cm, --meta-ecs   construct meta-equivalence classes
  -Cr, --read       use read() instead of stdio for scanner input
  -f, --full        generate fast, large scanner. Same as -Cfr
  -F, --fast        use alternate table representation. Same as -CFr
  -Cem              default compression (same as --ecs --meta-ecs)

Debugging:
  -d, --debug             enable debug mode in scanner
  -b, --backup            write backing-up information to lex.backup
  -p, --perf-report       write performance report to stderr
  -s, --nodefault         suppress default rule to ECHO unmatched text
  -T, --trace             flex should run in trace mode
  -w, --nowarn            do not generate warnings
  -v, --verbose           write summary of scanner statistics to stdout

Files:
  -o, --outfile=FILE      specify output filename
  -S, --skel=FILE         specify skeleton file
  -t, --stdout            write scanner on stdout instead of lex.yy.c
      --yyclass=NAME      name of C++ class
      --header-file=FILE   create a C header file in addition to the scanner
      --tables-file[=FILE] write tables to FILE

Scanner behavior:
  -7, --7bit              generate 7-bit scanner
  -8, --8bit              generate 8-bit scanner
  -B, --batch             generate batch scanner (opposite of -I)
  -i, --case-insensitive  ignore case in patterns
  -l, --lex-compat        maximal compatibility with original lex
  -X, --posix-compat      maximal compatibility with POSIX lex
  -I, --interactive       generate interactive scanner (opposite of -B)
      --yylineno          track line count in yylineno

Generated code:
  -+,  --c++               generate C++ scanner class
  -Dmacro[=defn]           #define macro defn  (default defn is '1')
  -L,  --noline            suppress #line directives in scanner
  -P,  --prefix=STRING     use STRING as prefix instead of "yy"
  -R,  --reentrant         generate a reentrant C scanner
       --bison-bridge      scanner for bison pure parser.
       --bison-locations   include yylloc support.
       --stdinit           initialize yyin/yyout to stdin/stdout
       --noansi-definitions old-style function definitions
       --noansi-prototypes  empty parameter list in prototypes
       --nounistd          do not include &lt;unistd.h&gt;
       --noFUNCTION        do not generate a particular FUNCTION

Miscellaneous:
  -c                      do-nothing POSIX option
  -n                      do-nothing POSIX option
  -?
  -h, --help              produce this help message
  -V, --version           report flex version

</pre>

`--help`的输出通常以`Usage: `开头，这部分概括了该命令的大致用法，如`flex --help`的这部分内容为（`#`后面的内容为注释）：
```
Usage: flex [OPTIONS] [FILE]...
```
其中`OPTIONS`表示选项，`FILE`表示文件（文件名），`...`表示可以有多个文件，`[]`里面的内容是可选的（即**OPTIONS**和**FILE**这两个参数都是可选的，如果不给出**FILE**这个参数的话，默认从标准输入（`stdin`读取）。从这里我们可以得知，该命令可以这样使用：
```
flex #从`stdin`读取，即需要手动输入 .l 文件
```
也可以这样使用：
```
flex a.l
```
还可以使用选项：
```
flex -o a.c a.l
```


`--help`的输出的第二行通常为该命令的简要描述，`flex`的是：
```
Generates programs that perform pattern-matching on text.
```
从这里我们可以得知，`flex`用于生成在文本上执行模式匹配的程序

之后的内容便是选项说明（甚至会分类）。Linux 及类 Unix 中的选项分为**长选项**和**短选项**，通常而言，每个选项都有长选项形式，而其中常用的选项会有短选项形式，短选项和相应的长选项等价（Windows CMD 没有这样的区分）。例如，如对于短选项`-v`（在分类`Debugging`下）：
```
  -v, --verbose           write summary of scanner statistics to stdout
```
其对应的长选项为`--verbose`。使用时`flex -v a.l`和`flex --verbose a.l`等价。

此外，有的选项需要传入参数，如`-o`：
```
  -o, --outfile=FILE      specify output filename
```
这时，我们需要传入`FILE`这个参数，如：
```
flex -o a.c a.l
```
其中`-o`和`a.c`之间的空格是可以省略的：
```
flex -oa.c a.l
```
同时，它和下面的用法等价：
```
flex --outfile=a.c a.l
```
此外，`--help`的输出中通常必定会有如下内容：
```
  -h, --help              produce this help message
  -V, --version           report xxx version
```
即对于任何命令，`-h, --help`和`-V, --version`总是可用的（有的不支持`-h`，有的不支持`--help`，试试就知道了）

另外，表示选项结束可以使用 `--`（即后面都是其它参数），如：
```
root@master:sj# ls
a  a.c  -a.l  a.l  a.out  a.yy.c  from-info-flex.l  lex.yy.c  Makefile  parser-generator
root@master:sj# flex -a.l
flex: Unrecognized option `a'
Try `flex --help' for more information.
root@master:sj# flex -- -a.l
root@master:sj#
```

### `man`
**温馨提示**：有的 Linux 发行版默认情况下可能没有安装`man`手册，这时可使用如下命令搜索并安装：
1. CentOS: 
   ```
   root@master:~# yum search man pages
   Loaded plugins: fastestmirror
   Loading mirror speeds from cached hostfile
	 ...
   man-db.x86_64 : Tools for searching and reading man pages
   man-pages.noarch : Man (manual) pages from the Linux Documentation Project
   ...
   man-pages-zh-CN.noarch : Chinese Man Pages from Chinese Man Pages Project
   ...
   root@master:~# yum install man-pages
   ```
   注意其中还有中文手册（即`man-pages-zh-CN`），但是笔者并不推荐，因为它不够新、翻译可能有误、不利于我们养成阅读英文文献的好习惯

2. Ubuntu:
   ```
   wsxq2@ubuntu-server:~$ apt search man pages -n
   Sorting... Done
   Full Text Search... Done
   ...
   manpages/xenial,xenial,now 4.04-2 all [installed]
     Manual pages about using a GNU/Linux system
   ...
   manpages-dev/xenial,xenial,now 4.04-2 all [installed,automatic]
     Manual pages about using GNU/Linux for development
   ...
   manpages-posix/xenial,xenial 2013a-1 all
     Manual pages about using POSIX system
   
   manpages-posix-dev/xenial,xenial 2013a-1 all
     Manual pages about using a POSIX system for development
   ...
   manpages-zh/xenial,xenial 1.5.2-1.1 all
     Chinese manual pages
   ...
   wsxq2@ubuntu-server:~$ apt install manpages manpages-dev manpages-posix manpages-posix-dev
   ```
   同样地，其中的中文手册（`manpages-zh`）不建议安装
   
`man`是除了`--help`使用最多的帮助命令。我们可以使用如下命令查看`man`命令的帮助：
```
man --help
```
可以看到，其用法如下：
```
Usage: man [OPTION...] [SECTION] PAGE...
```
即只有`PAGE`参数是必需的。`PAGE`参数即你要看的页面，通常为**命令名**，还可以为其它东西，如标准 C 的**函数名**，甚至**配置文件**等。例如：
```
man man
man flex
man sprinf
man resolv.conf #resolv.conf是Linux下配置DNS的文件
```
在使用`man`来查看帮助前，我们应当先阅读`man man`以学会使用`man`命令。这里就不详细说明了（因为`man man`里的内容已经足够详细了）。下面列出它常用的几个参数：
```
  -a, --all                  find all matching manual pages
  -w, --where, --path, --location
                             print physical location of man page(s)
  -P, --pager=PAGER          use program PAGER to display output
  -f, --whatis               equivalent to whatis
  -k, --apropos              equivalent to apropos
  -K, --global-apropos       search for text in all pages
  -l, --local-file           interpret PAGE argument(s) as local filename(s)
  -L, --locale=LOCALE        define the locale for this particular man search
  -M, --manpath=PATH         set search path for manual pages to PATH
  -E, --encoding=ENCODING    use selected output encoding
```
它的常用用法如下：
```
man -aw PAGE
man -P less PAGE
man -L zh-cn PAGE #使用yum install man-pages-zh-CN.noarch命令安装中文手册，但是并不推荐，因为中文不够新，且可能有翻译错误
```

### `info`
`info`的内容非常详细，它是有目录的，整理得比较合理。强烈推荐使用（反正我是后悔没有早早地学会它）。关于`info`的使用可以参见`info --help`、`man info`和`info info`。这里只给出`info`中常用的快捷键（它的风格和`vim`很不像，且各个平台可能有所不同）：

<pre>
C-g         Cancel the current operation.

l           Close this help window.
q           Quit Info altogether.
H           Invoke the Info tutorial.

Up          Move up one line.
Down        Move down one line.
DEL         Scroll backward one screenful.
SPC         Scroll forward one screenful.

TAB         Skip to the next hypertext link.
RET         Follow the hypertext link under the cursor.
l           Go back to the last node seen in this window.

[           Go to the previous node in the document.
]           Go to the next node in the document.
p           Go to the previous node on this level.
n           Go to the next node on this level.
u           Go up one level.
t           Go to the top node of this document.

m           Pick a menu item specified by name.
g           Go to a node specified by name.

s           Search forward for a specified string.
{           Search for previous occurrence.
}           Search for next occurrence.
</pre>
注意`info`的部分快捷键好像不是固定的，要注意随机应变

## bash 自动补全
### 使用包管理器安装
```
yum install bash-completion -y # for CentOS
apt isntall bash-completion -y # for Ubuntu
```

### 从源码安装
到 [Releases · scop/bash-completion](https://github.com/scop/bash-completion/releases) 页面下载最新发布版本（当前是 2.9），然后解压：
```
tar xf bash-completion-2.9.tar.xz
```
安装：
```
cd bash-completion-2.9
autoreconf -i  # if not installing from prepared release tarball
./configure
make
make check # optional, requires python3 with pytest >= 3.6 and pexpect, dejagnu, and tcllib
make install # as root
```
然后在你的`~/.bashrc`中添加如下内容：
```
# bash_completion
function bash_completion()
{
	# Check for interactive bash and that we haven't already been sourced.
	[ -z "$BASH_VERSION" -o -z "$PS1" -o -n "$BASH_COMPLETION_COMPAT_DIR" ] && return

	# Check for recent enough version of bash.
	bash=${BASH_VERSION%.*}; bmajor=${bash%.*}; bminor=${bash#*.}

	if [ $bmajor -gt 4 ] || [ $bmajor -eq 4 -a $bminor -ge 1 ]; then
		[ -r "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion" ] && \
			. "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion"

        bash_completion_script=$([[ -r /usr/share/bash-completion/bash_completion ]] && \
            echo /usr/share/bash-completion/bash_completion || \
            echo /usr/local/share/bash-completion/bash_completion)
        if shopt -q progcomp && [ -r $bash_completion_script ]; then
            # Source completion code.
            . $bash_completion_script
        fi

        if [[ -x /etc/bash_completion.d ]];then
            for x in /etc/bash_completion.d/*;do
                . $x
            done
        fi
	fi
	unset bash bmajor bminor
}
bash_completion
```

然后就可以使用各种命令的自动补全了，比如`openssl`：
```
root@master:~# openssl <tab>
Display all 101 possibilities? (y or n)
aes-128-cbc       bf-ecb            cast5-cfb         des-ecb           dgst              gendsa            pkcs8             rc2-ecb           sha1              version
aes-128-ecb       bf-ofb            cast5-ecb         des-ede           dh                genpkey           pkey              rc2-ofb           sha224            x509
aes-192-cbc       ca                cast5-ofb         des-ede3          dhparam           genrsa            pkeyparam         rc4               sha256
aes-192-ecb       camellia-128-cbc  cast-cbc          des-ede3-cbc      dsa               md2               pkeyutl           rc4-40            sha384
aes-256-cbc       camellia-128-ecb  ciphers           des-ede3-cfb      dsaparam          md4               prime             req               sha512
aes-256-ecb       camellia-192-cbc  crl               des-ede3-ofb      ec                md5               rand              rmd160            smime
asn1parse         camellia-192-ecb  crl2pkcs7         des-ede-cbc       ecparam           nseq              rc2               rsa               speed
base64            camellia-256-cbc  des               des-ede-cfb       enc               ocsp              rc2-40-cbc        rsautl            spkac
bf                camellia-256-ecb  des3              des-ede-ofb       engine            passwd            rc2-64-cbc        s_client          s_server
bf-cbc            cast              des-cbc           des-ofb           errstr            pkcs12            rc2-cbc           sess_id           s_time
bf-cfb            cast5-cbc         des-cfb           desx              gendh             pkcs7             rc2-cfb           sha               verify
```

又比如`yum`：
```
root@master:_posts# yum <tab>
check             deplist           groups            info              load-transaction  reinstall         search            upgrade
check-update      distro-sync       help              install           makecache         remove            shell             version
clean             downgrade         history           list              provides          repolist          update
```

### 调试
追踪`bash`启动时加载了哪些文件（可以使用关键字`bash startup trace`搜索）：
```
echo exit | strace bash -li |& grep '^open[a-z]*'
```

我的`CentOS 7`运行的结果如下（去掉了非配置文件的内容）：
```
open("/etc/profile", O_RDONLY)          = 3
open("/etc/profile.d/*", O_RDONLY) = 3
open("/root/.bash_profile", O_RDONLY)   = 3
open("/root/.bashrc", O_RDONLY)         = 3
open("/usr/local/share/bash-completion/bash_completion", O_RDONLY) = 3
open("/root/.bash_history", O_RDONLY)   = 3
open("/root/.inputrc", O_RDONLY)        = 3
open("/root/.bash_logout", O_RDONLY)    = 3
open("/etc/bash.bash_logout", O_RDONLY) = -1 ENOENT (No such file or directory)
```

详情参见 [profile - Find out what scripts are being run by bash on startup - Unix & Linux Stack Exchange](https://unix.stackexchange.com/questions/334382/find-out-what-scripts-are-being-run-by-bash-on-startup)

### bash 加载配置文件的顺序
参见 [Bash Startup Files (Bash Reference Manual)](https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html)


## Expansion
如果想了解一些基本的 Shell Expansion（如通配符，`~`，数学运算，`{}`拓展，`$variable`引用，`$()`，单引号，双引号，转义字符，反斜杠），可以参考 [Expansion](http://linuxcommand.org/lc3_lts0080.php)以及`man bash`中的`^EXPANSION`（使用`/`搜索）部分

## Readline
Readline 用于处理交互式 Shell 的输入，充分利用可以使得输入命令的效率大大提高。但由于本身非常复杂，所以选择重点的常用的记住并反复使用即可。参见 [Readline(Emacs) Cheat Sheet](https://readline.kablamo.org/emacs.html) 和 [Readline(vi) Cheat Sheet](https://readline.kablamo.org/vi.html)

详情参见`man bash`中的`^READLINE`部分

## 字符串
### 拼接字符串
本部分内容参考自 [shell - How to concatenate string variables in Bash - Stack Overflow](https://stackoverflow.com/questions/4181703/how-to-concatenate-string-variables-in-bash)

#### 使用 `""`
```
$ foo="Hello"
$ foo="$foo World"
$ echo $foo
Hello World
$ a='hello'
$ b='world'
$ c="$a$b"
$ echo $c
helloworld
```

#### 使用 `+=`
```
$ A="X Y"
$ A+=" Z"
$ echo "$A"
X Y Z
$ a=2
$ a+=4
$ echo $a
24
```

#### 使用 `printf`
```
$ foo="Hello"
$ printf -v foo "%s World" $foo
$ echo $foo
Hello World
```

### 字符串匹配通配符
#### `=`
参见 [使用`=`](#使用-1)

#### `case..in..`
参见 [使用`case..in..`](#使用casein)

### 字符串匹配正则表达式
该部分参考自 [Check if a string matches a regex in Bash script - Stack Overflow](https://stackoverflow.com/questions/21112707/check-if-a-string-matches-a-regex-in-bash-script)

#### `=~`
```
[[ $date =~ ^[0-9]{8}$ ]] && echo "yes"
```

#### `expr match`
```
expr match "$date" "^[0-9]\{8\}" >/dev/null && echo yes
```

## 算术运算
### 整数运算
#### `$(())`
   ```
   $ echo "$((5*5+5-3/2))"
   29
   ```
#### `expr`
   ```
   $ expr 5 - 4
   1
   ```

### 浮点运算
#### `bc`
   ```
   $ echo "5.01-4*2.0"|bc
   -2.99
   ```
#### `awk`
   ```
   $ awk 'BEGIN{print 7.01*5-4.01}'
   31.04
   ```

## 输入输出（IO）
### 从文件或`stdin`中读取输入
```
while read line
do
  echo "$line"
done < "${1:-/dev/stdin}"
```
以上脚本实现：执行该脚本时将第一个参数视为文件名，从该文件中读取输入；如果没有传入参数，则从`/dev/stdin`（即标准输入读取输入）

`${1:-/dev/stdin}`根据条件执行替换，即如果`$1`（传入脚本的第一个参数）不存在则由`/dev/stdin`替换。

详情参见 [How to read from a file or stdin in Bash? - Stack Overflow](https://stackoverflow.com/questions/6980090/how-to-read-from-a-file-or-stdin-in-bash)

### 输入 ASCII 特殊字符
该部分的测试环境如下：
* 主机操作系统：Windows 10 1803
  * 使用的 SSH 工具：Putty 0.70
* 虚拟机操作系统：CentOS 7.2
  * 使用的 Shell: Bash 4.2.46

#### 使用`echo`或`printf`
```
echo -ne '\x05\x01\x00'|nc -x nc.log localhost 1080
```
或者：
```
echo -n $'\x05\x01\x00'|nc -x nc.log localhost 1080
```
不过上述方法中，后一种方法似乎无法输入`\x00`字符

`printf`和上述方法类似

#### 使用`python`
> If you don't wan't to create a file, here's an alternative
> 
> ```
> python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
> ```
> 
> If you want stdin control to be transferred back
> 
> ```
> ( python -c 'print("\x61\x62\x63\x64")' ; cat ) | /path/to/exe
> ```
> ——引用自[bash - Type characters in hexadecimal notation to standard input - Stack Overflow](https://stackoverflow.com/questions/41559398/bash-type-characters-in-hexadecimal-notation-to-standard-input)

#### 使用重定向`<`
```
echo -ne '\x05\x01\x00\x04\x05\x01\x00\x03\x0e\x77\x77\x77\x2e\x67\x6f\x6f\x67\x6c\x65\x2e\x63\x6f\x6d\x01\xbb' >input
nc -x nc.log localhost 1080 < input
```
但是上述两种方法（`echo`和`<`）都只能发送一次消息，因此实在让人难以满意。于是经过大量的搜索，我找到了如下解决方案

#### 直接输入
如果是在标准输入状态下（例如使用了`cat`命令，需要从标准输入读取数据），可以直接参见 [ASCII - Wikipedia](https://en.wikipedia.org/wiki/ASCII#Control_characters) 的那个表格，我们可以知道`^@`（`Ctrl+2`）表示 ASCII 字符`\x00`，`^A`（`Ctrl+A`）表示 ASCII 字符`\x01`，以此类推，可以轻松输入任意 ASCII 特殊字符

如果是在`Bash`中输入命令，则可以在上述方法中先加一个`Ctrl+V`键即可。例如你想要输入`\x01`，实际输入`Ctrl+V,Ctrl+A`即可。这个方法存在一个显著的问题，那就是`\x00`无法输入。此外还存在一个小问题，如`\x127`（`^?`）不能通过`Ctrl+V, Ctrl+/`或`Ctrl+V, Ctrl+?`输入，但是可以通过`Ctrl+V, Ctrl+BackSpace`（或者输入`Ctrl+V, BackSpace`）来输入。关于`Bash`中可用的用于改变文本的快捷键可参考`man bash`中的`Commands for Changing Text`部分，其中提到：

> quoted-insert (C-q, C-v)
>
> Add the next character typed to the line verbatim.  This is how to insert characters like C-q, for example.

不过我觉得`C-q`和`C-v`的顺序写反了

由于`Bash`中的快捷键是通过`readline`库实现的，所以更多信息可参考 [The GNU Readline Library](https://tiswww.cwru.edu/php/chet/readline/rltop.html)

常用的快捷键的参考手册（emacs模式）：[Readline Cheat Sheet](https://readline.kablamo.org/emacs.html)

常用的快捷键的参考手册（vi模式）：[Readline Cheat Sheet](https://readline.kablamo.org/vi.html)


## 路径相关
### 转换相对路径为绝对路径
本部分参考自 [shell - Bash: retrieve absolute path given relative - Stack Overflow](https://stackoverflow.com/questions/4175264/bash-retrieve-absolute-path-given-relative/31605674)

```
relative_path="../../program/py/hack/get_host.sh"
```

#### `$PWD`
```
echo "$PWD/$relative_path"
```

#### `realpath`
```
echo `realpath $relative_path`
```

### `dirname && basename`
> ```
> dirname /usr/bin/
>  -> "/usr"
> 
> dirname dir1/str dir2/str
>  -> "dir1" followed by "dir2"
> 
> dirname stdio.h
>  -> "."
> 
> basename /usr/bin/sort
>  -> "sort"
> 
> basename include/stdio.h .h
>  -> "stdio"
> 
> basename -s .h include/stdio.h
>  -> "stdio"
> 
> basename -a any/str1 any/str2
>  -> "str1" followed by "str2"
> ```
> 
> ——引用自`man dirname`和`man basename`


## 进制转换
### any base to decimal?
```
echo "obase=10; ibase=16; $hexNum" | bc
echo $((16#$hexNum))
```
其中第一种方法是使用了 bc，自不必多说。而后一种方法就很有意思了，它使用了 Bash Expansion 中的**Arithmetic Expansion**（`$((EXP))`）：

> Constants with a leading 0 are interpreted as octal numbers.  A leading 0x or 0X denotes hexadecimal.  Otherwise, numbers take the form [base#]n, where the  optional  base  is  a decimal  number between 2 and 64 representing the arithmetic base, and n is a number in that base.  If base# is omitted, then base 10 is used.  The digits greater than 9 are represented by the lowercase letters, the uppercase letters, @, and _, in that order.  If base is less than or equal to 36, lowercase and uppercase letters may be used  interchangeably to represent numbers between 10 and 35.
> 
> ——引用自`man bash`中的**ARITHMETIC EVALUATION**部分（可使用`/^AR`快速到达）

详情参见 [Convert Hexadecimal to Decimal in Bash – Linux Hint](https://linuxhint.com/convert_hexadecimal_decimal_bash/)

### hex number to binary string?
```
echo 'ibase=16;obase=2;5f' | bc
perl -e 'printf "%08b\n", 0x5D'
printf '\x5F' | xxd -b | cut -d' ' -f2
```

## 管道
### grep through `|` can't get stderr content?
gcc 的`-v`参数会将详细信息输出到标准错误`stderr`，直接使用管道得到的输入为空。如下所示:
```
root@master:tmp# gcc -v a.c | grep cc1
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper
Target: x86_64-redhat-linux
...
```
但是我们可以这样：
```
root@master:tmp# gcc -v a.c |& grep cc1
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -quiet -v a.c -quiet -dumpbase a.c -mtune=generic -march=x86-64 -auxbase a -version -o /tmp/cc92AIgc.s
```
其中`|&`和`2&1 |`等价：

> If |& is used, the standard error of command is connected to command2's standard input through the pipe; it is shorthand for 2>&1 |.  This implicit redirection of the standard error is performed after any redirections specified by the command
> 
> ——引用自`man bash`（使用`/|&`快速跳转到相应位置）


## 捕获信号
### 响应`ctrl+c`
> Try the following code :
> 
> ```
> #!/bin/bash
> # type "finish" to exit
> 
> # function called by trap
> other_commands() {
>     printf "\rSIGINT caught      "
>     sleep 1
>     printf "\rType a command >>> "
> }
> 
> trap 'other_commands' SIGINT
> 
> input="$@"
> 
> while true; do
>     printf "\rType a command >>> "
>     read input
>     [[ $input == finish ]] && break
>     bash -c "$input"
> done
> ```
> 
> ——引用自 [BASH - using trap ctrl+c - Stack Overflow](https://stackoverflow.com/a/12771964)


## 自定义环境
### 列出所有自定义函数？
列出所有函数：
```
declare -F
```
参见 [bash - How do I list the functions defined in my shell? - Stack Overflow](https://stackoverflow.com/questions/4471364/how-do-i-list-the-functions-defined-in-my-shell)

列出所有自定义函数（并不准确）：
```
declare -F |awk '{print $3}' | egrep '^[a-z0-9]{1,5}$'
```

### 列出所有自定义变量？

```
 # my environment
alias me="env | grep '^[a-z]\+='"
```


## 遇到过的问题
### 转换 Windows 风格的换行符为 Linux 风格
Windows 的文本文件使用的换行符是`\r\n`（CRLF）；Linux 的是`\n`（LF）。此外，MacOS 以前使用的是`\r`（CR），不过现在也和 Unix 一样了。而转换方法有很多，如使用`vim`、`tr`、`sed`、`dos2unix`。这部分内容主要参考自： [linux - How to convert DOS/Windows newline (CRLF) to Unix newline (LF) in a Bash script? - Stack Overflow](https://stackoverflow.com/questions/2613800/how-to-convert-dos-windows-newline-crlf-to-unix-newline-lf-in-a-bash-script)和 [HowTo: UNIX / Linux Convert DOS Newlines CR-LF to Unix/Linux Format - nixCraft](https://www.cyberciti.biz/faq/howto-unix-linux-convert-dos-newlines-cr-lf-unix-text-format/)

#### `vim`
Vim 作为一个极为强大的文本编辑器，处理这点小问题自然不在话下：
```
vim file.txt -c "set ff=unix" -c ":wq" # Windows to Linux
vim file.txt -c "set ff=dos" -c ":wq" # Linux to Windows
```

#### `dos2unix`
`dos2unix`和`unix2dos`命令均来自包`dos2unix`，在 CentOS 中可以使用如下命令安装：
```
yum install dos2unix
```
然后可以使用如下方法使用它：
```
dos2unix <filename> #原地转换
dos2unix -n <input-file> <output-file> #生成新文件，保留副本
```

当然，也可以使用`unix2dos`反向转换

#### `tr`
`tr`是 translate 的缩写，即有*转换*和*翻译*之意。它是 Linux 中的一个非常常用的小工具（属于软件包`coreutils`），用来删除或是转换全文中的某些字符。详情参见`man tr`

由于 Windows 和 Linux 换行符的差异在于 Windows 多了一个`\r`，所以删除它即可：
```
tr -d '\r' <infile >outfile
```

#### `sed`
`sed`是 Linux 中的一个文本流编辑器。使用它也可以删除`\r`字符从而达到目的
```
sed -e 's/\r//g' <infile >outfile
```
此外，如果是在交互式的`bash`中使用，可以通过下面的方法输入特殊字符`\r`：**press Ctrl-V then Ctrl-M**。如：
```
sed 's/^M$//' input.txt > output.txt
```

### 将 ls 的输出赋值给 Arrays 变量
本部分参考自 [How do I assign ls to an array in Linux Bash? - Stack Overflow](https://stackoverflow.com/questions/18884992/how-do-i-assign-ls-to-an-array-in-linux-bash)

Bash 支持一维数组（数字索引和字符串索引），关于 Bash 中数组的更多知识，可参见`info bash 'bash feature' array`（也可以参见`man bash`）。其中有提到给数组赋值的方法，即：
```
declare -a a #可选
a=(a b c d)
```
引用时使用`${a[0]}`、`${a[1]}`……即可。此外，使用`${a[@]}`可以获得数组的所有成员（注意和`${a[*])}`有所区别）；使用`${#a[0]}`可以获得 a[0] 的长度，类似地，使用`${#a[@]}`可以获得数组 a 的长度

因此，一个简单的方法是：
```
array=($(ls -d */))
```
事实上，直接这样就可以了：
```
array=(*/)
```

然而，上述方法不能很好地处理文件名中有特殊符号的情形（如空格）。因此稳健的方法如下：

```
shopt -s nullglob
array=(*/)
shopt -u nullglob # Turn off nullglob to make sure it doesn't interfere with anything later
echo "${array[@]}"  # Note double-quotes to avoid extra parsing of funny characters in filenames
if (( ${#array[@]} == 0 )); then
    echo "No subdirectories found" >&2
fi
```

## 实践记录
### 处理缩略语
问题详情参见 [Sed使用笔记 - 处理缩略语](https://wsxq2.55555.io/blog/2019/04/20/sed%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/#%E5%A4%84%E7%90%86%E7%BC%A9%E7%95%A5%E8%AF%AD)

#### 使用`grep`
```
temp=$IFS
IFS=
while read line
do
	tmp=$(grep -h "^\*\[$line\]" abbreviations.txt)
	if [[ -z $tmp ]]; then
		tmp="*[$line]: "
	fi
	echo $tmp
done < "${1:-/dev/stdin}"
IFS=$temp
```
注意`$()`命令需要修改`IFS`以保证`$tmp`变量不会丢失换行符，详情参见：
[shell - Why do newline characters get lost when using command substitution? - Unix & Linux Stack Exchange](https://unix.stackexchange.com/questions/164508/why-do-newline-characters-get-lost-when-using-command-substitution#answer-164548)

#### 使用`case..in..`
```
while read word
do
	tmp=
	while read abbr
	do
		glob="\*\[$word\]:*"
		case $abbr in
			 $glob )
				if [[ $tmp ]]; then
					tmp="$tmp\n$abbr";
				else
					tmp=$abbr;
				fi
				;;
		esac
	done < abbreviations.txt
	if [[ -z $tmp ]]; then
		tmp="*[$word]: "
	fi
	echo -e $tmp
done < "${1:-/dev/stdin}"
```

#### 使用`=~`
```
while read word
do
	tmp=
	while read abbr
	do
		regex="^\*\[$word]:.*\$"
		if [[ $abbr =~ $regex ]]; then
			if [[ $tmp ]]; then
				tmp="$tmp\n$abbr";
			else
				tmp=$abbr;
			fi
		fi
	done < abbreviations.txt
	if [[ -z $tmp ]]; then
		tmp="*[$word]: "
	fi
	echo -e $tmp
done < "${1:-/dev/stdin}"
```

#### 使用`=`
```
while read word
do
	tmp=
	while read abbr
	do
		glob="\*\[$word\]:*"
		if [[ $abbr = $glob ]]; then
			if [[ $tmp ]]; then
				tmp="$tmp\n$abbr";
			else
				tmp=$abbr;
			fi
		fi
	done < abbreviations.txt
	if [[ -z $tmp ]]; then
		tmp="*[$word]: "
	fi
	echo -e $tmp
done < "${1:-/dev/stdin}"
```

### 将 Windows 格式的文本文件转换为 Linux 格式
每当我使用 Linux 中的 Vim 打开 Windows 上编辑的含有中文的文本文件时，它会在最下面出现如下提示（尤其是使用记事本）：
```
"main.cpp" [noeol][converted][dos] 196L, 4767C
```
由此总结出 Windows 的文本文件和 Linux 中的文本文件在格式上的区别如下：
* Windows 的文本文件可能没有`eof`；Linux 的通常都有。可以使用 sed 工具解决这个问题：
  ```
  sed -e '$s/.*/&\n/' < infile > outfile
  ```
  
* Windows 的文本文件编码通常为`cp936`；Linux 的则为`UTF-8`。可以使用`iconv`进行转换：
  ```
  iconv -f CP936 -t UTF-8 < infile > outfile
  ```
  
* Windows 的文本文件使用的换行符是`\r\n`（CRLF）；Unix 的是`\n`（LF）。此外，MacOS 以前使用的是`\r`（CR），不过现在也和 Unix 一样了。可以使用`tr`工具删除多余的`\r`：
  ```
  tr -d '\r' < infile > outfile
  ```

从而写出了如下脚本：
```
all_source_file=$(find . -path ./after_iconv -prune -o \( -name '*.cpp' -o -name '*.h' -o -name '*.txt' \) -print)
#echo ${all_source_file[1]}

touch temp1 temp2
for f in $all_source_file; do
        #echo $f
        dir_of_f=after_iconv/$(dirname $f)
        #echo $dir_of_f
        if [[ ! -d $dir_of_f ]]; then
                echo mkdiring $dir_of_f
                mkdir -p $dir_of_f
        fi
        echo iconving $f to after_iconv/$f
        #iconv -f CP936 -t UTF-8 -o after_iconv/$f $f
        iconv -f CP936 -t UTF-8 -o ./temp1 $f
        sed -e '$s/.*/&\n/' <temp1 > temp2
        tr -d '\r' < ./temp2 > after_iconv/$f
done
rm -f temp1 temp2
```
它的功能是将当前目录下所有的文件名以`.cpp`、`.h`、`.txt`结尾的文件找出来，并将它们的格式从 Windows 转换为 Linux。以便在 Linux 中编译运行

事实上，可以直接使用 Vim 实现上述功能：
```
vim file.txt -c "set ff=unix" -c ":wq" # 处理换行符问题：将 \r\n 改为 \n
vim file.txt -c "set fenc=utf8" -c ":wq" # 处理文件编码问题：将 cp936 转换为 utf8
vim file.txt -c "$s/.*/&\n/" -c ":wq" # 处理 eof 问题：在最后一行后添加 \n。这一步好像不必要
```

不过使用 Vim 处理大量文件时效率比较低下，这点还需注意

### dream 项目中的需求
```
#!/bin/bash
declare will_exit=false
function prepare_exit(){
        echo "检测到 CTRL+C，程序将在完成本轮操作后退出……"
        will_exit=true
}

trap prepare_exit SIGINT

declare -i i=1
while true
do
        echo "第 $i 轮开始……"
        echo "远程执行脚本……"
        ssh -p26635 root@wsxq21.55555.io "cd ~/dream/ && python3 main.py"
        echo "下载到本地……"
        scp -P26635 root@wsxq21.55555.io:~/dream/videos/* /mnt/d/learn/
        echo "删除远程主机上的文件……"
        ssh -p26635 root@wsxq21.55555.io "rm -rf ~/dream/videos/*"
        echo "第 $i 轮完成！"
        [[ $will_exit ]] && break
        i+=1
done
```


## 链接
下面总结了本文中使用的所有链接：

<!-- link start -->

* [How to read from a file or stdin in Bash? - Stack Overflow](https://stackoverflow.com/questions/6980090/how-to-read-from-a-file-or-stdin-in-bash)
* [Sed使用笔记 - 处理缩略语](https://wsxq2.55555.io/blog/2019/04/20/sed%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/#%E5%A4%84%E7%90%86%E7%BC%A9%E7%95%A5%E8%AF%AD)
* [The Linux Command Line 中文版](https://www.kancloud.cn/thinkphp/linux-command-line/39431)
* [shell - Bash: retrieve absolute path given relative - Stack Overflow](https://stackoverflow.com/questions/4175264/bash-retrieve-absolute-path-given-relative/31605674)
* [shell - How to concatenate string variables in Bash - Stack Overflow](https://stackoverflow.com/questions/4181703/how-to-concatenate-string-variables-in-bash)
<!-- link end -->


<!-- abbreviations start -->

<!-- abbreviations end -->


