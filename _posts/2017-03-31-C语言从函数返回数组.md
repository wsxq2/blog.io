**版权相关**：本文修改自[【原】C语言函数返回数组的问题](https://www.cnblogs.com/wuqi1003/archive/2013/01/09/2853657.html)

有些时候需要子函数将一个数组返回出来，通常是两种方法，一种是靠**指针**，另一种是**结构体**。
## 一、使用指针
1、 对于char数组可以使用`char*`：
<pre>
#include "stdio.h"

char *test()
{
    //char tmp[30]="第一个测试例子\n";//写成这样编译时弹出警告，最后的结果也是乱码
    char *tmp="第一个测试例子";//写成这样可以用指针返回数组首地址
    return tmp;
}

void main(void)
{
    printf("%s",test());
}
</pre>
**解释**：之所以`*tmp`可以而`tmp[30]`不可以，是因为`tmp[30]`是个局部变量，子函数结束时该数组地址虽然没变，但是里面的值已经无意义了，而`*tmp`是定义了一个全局变量(待定)。

2、 对于普通数组，可以使用`static`这个关键字：
<pre>
#include "stdio.h"

char *test()
{
    static char tmp[30]="第二个测试例子";
    return tmp;
}

void main(void)
{
    printf("%s",test());
}
</pre>
**解释**：在数组`tmp[30]`前面加入了`static`关键字,它就使得`tmp[30]`存放在内存中的静态存储区中,所占用的存储单元一直不释放直到整个程序运行结束.所以当主函数调用完`print()`函数后,该空间依然存在.所以`main()`函数中获得首地值后可以访问数组中的元素.
## 二、使用结构体
<pre>
#include "stdio.h"
#include "string.h"

struct ret
{
    char buf[30];
};//定义结构体时不要忘了分号

struct ret test(char *tmp)
{
    struct ret a;
    strcpy(a.buf,tmp);
    return a;
}


void main(void)
{
    struct ret b;
    b=test("用结构体作为返回值传递数组");
    printf("%s",b.buf);
}
</pre>
**注意**：数组之间的赋值不能直接赋值，即不要直接将数组A赋给数组B，而是要用`strcpy`（**字符型数组**）或者`memcpy`（**非字符型数组**）。
