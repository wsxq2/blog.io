---
layout: post
tags: [python2.7,TODO]
categories: blog
---

本文来自Python官方文档：<https://docs.python.org/2/tutorial/index.html>


<!-- vim-markdown-toc GFM -->

* [2 Python Interpreter](#2-python-interpreter)
  * [2.1 Invoking the Interpreter](#21-invoking-the-interpreter)
  * [2.2 Interactive Mode](#22-interactive-mode)
* [Math](#math)
* [Strings](#strings)
* [Lists](#lists)
* [4 Control Flow Statements](#4-control-flow-statements)
  * [4.1 `if` Statements](#41-if-statements)
  * [4.2 `for` Statements](#42-for-statements)
  * [4.3 `while` Statements](#43-while-statements)
  * [4.4 `break`, `continue` and `else` in Loops](#44-break-continue-and-else-in-loops)

<!-- vim-markdown-toc -->

## 2 Python Interpreter
### 2.1 Invoking the Interpreter
Python's default **path** is `/usr/local/bin/python`(Linux) or `C:\python27`(Windows)
* **start**:
    1. `python`
    2. `python [-i] <source file>`
    4. `python -c command [arg] ...`
    3. `python -m module [arg] ...`
* **Argument Passing**:

    > When known to the interpreter, the script name and additional arguments thereafter are turned into a list of strings and assigned to the `argv` variable in the `sys` module. You can access this list by executing `import sys`. The length of the list is at least one; when no script and no arguments are given, `sys.argv[0]` is an empty string. When the script name is given as `'-'` (meaning standard input), `sys.argv[0]` is set to `'-'`. When `-c` command is used, `sys.argv[0]` is set to `'-c'`. When `-m` module is used, `sys.argv[0]` is set to the full name of the located module. Options found after `-c` command or `-m` module are not consumed by the Python interpreter’s option processing but left in `sys.argv` for the command or module to handle.
* **Source Code Encoding**:

  ```
  #!/usr/bin/env python
  # -*- coding: utf-8 -*-
  ```

### 2.2 Interactive Mode
In this mode it prompts for the next command with the primary prompt, usually three greater-than signs (`>>>`); for continuation lines it prompts with the secondary prompt, by default three dots (`...`). The last printed expression is assigned to the variable `_`.
```python
>>> 100.50 * (12.5)/100
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
```

* **start**: `python`
* **quit**: 
1. use `end-of-file character` (`Control-D` on Unix, `Control-Z` on Windows)
2. use `quit()`

* **GNU readline library**: support for the [**GNU readline library**](https://tiswww.case.edu/php/chet/readline/rltop.html)(which adds more elaborate **interactive editing** and **history features**).
The current line can be edited using the conventional **Emacs control characters**. 
  1. Line Editing
     * `C-A`: (Control-A) moves the cursor to the beginning of the line
     * `C-E`: to the end
     * `C-B`: moves it one position to the left
     * `C-F`: to the right. Backspace erases the character to the left of the cursor
     * `C-D`: the character to its right. C-K kills (erases) the rest of the line to the right of the cursor
     * `C-Y`: yanks back the last killed string
     * `C-_`: undoes the last change you made; it can be repeated for cumulative effect.

   2. History Substitution
      * `C-P`: moves one line up (back) in the history buffer
      * `C-N`: moves one down. 
      * `C-R`: starts an incremental reverse search
      * `C-S`: starts a forward search

   3. Key Bindings(in `~/.inputrc`)
      * bind key: `key-name: function-name`, `"string": function-name`
      * set options: `set option-name value`
      * examples:

        <pre>
        # ~/.inputrc

        # set vi-style editing:
        set editing-mode vi
    
        # Edit using a single line:
        set horizontal-scroll-mode On
    
        # Rebind some keys:
        Meta-h: backward-kill-word
        "\C-u": universal-argument
        "\C-x\C-r": re-read-init-file

        # make Tab be used for complete
        Tab: complete
        </pre>

* **startup file**: Python will execute the contents of a file identified by the `PYTHONSTARTUP` **environment variable** when you start an interactive interpreter.

  ```python
  # Add auto-completion and a stored history file of commands to your Python
  # interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
  # bound to the Esc key by default (you can change it - see readline docs).
  #
  # Store the file in ~/.pystartup, and set an environment variable to point
  # to it:  "export PYTHONSTARTUP=~/.pystartup" in bash.
  
  import atexit
  import os
  import readline
  import rlcompleter
  
  historyPath = os.path.expanduser("~/.pyhistory")
  
  def save_history(historyPath=historyPath):
      import readline
      readline.write_history_file(historyPath)
  
  if os.path.exists(historyPath):
      readline.read_history_file(historyPath)
  
  atexit.register(save_history)
  
  # use <Control-O> for complete
  # readline.parse_and_bind('"\C-O": complete')

  del os, atexit, readline, rlcompleter, save_history, historyPath

  ```

* **Alternatives**: One alternative enhanced interactive interpreter that has been around for quite some time is [IPython](https://ipython.org/), which features **tab completion**, **object exploration** and **advanced history management**. It can also be **thoroughly customized** and **embedded** into other applications. Another similar enhanced interactive environment is [bpython](https://www.bpython-interpreter.org/).


comment: `#`

## Math
* **operators**: 
  * fundamental operations: `+`, `-`, `*`, `/`
  * `%`: remainder
  * `//`: explicit floor division discards the fractional part
  * `**`: power

  ```python
  >>> 17 / 3  # int / int -> int
  5
  >>> 17 / 3.0  # int / float -> float
  5.666666666666667
  >>> 17 // 3.0  # explicit floor division discards the fractional part
  5.0
  >>> 17 % 3  # the % operator returns the remainder of the division
  2
  >>> 5 * 3 + 2  # result * divisor + remainder
  17
  ```

* **type of numbers**: `int`, `float`, `Decimal`, `Fraction`, `complex`

## Strings
* **`""` and `''`**: The only difference between `""` and `''` is that within single quotes you don’t need to escape `"` (but you have to escape `\'`) and vice versa.

* **default output and `print()`**:
> In the interactive interpreter, the output string is enclosed in quotes and special characters are escaped with backslashes. While this might sometimes look different from the input (the enclosing quotes could change), the two strings are equivalent. The string is enclosed in double quotes if the string contains a single quote and no double quotes, otherwise it is enclosed in single quotes. The print statement produces a more readable output, by omitting the enclosing quotes and by printing escaped and special characters:
  ```python
  >>> '"Isn\'t," they said.'
  '"Isn\'t," they said.'
  >>> print '"Isn\'t," they said.'
  "Isn't," they said.
  >>> s = 'First line.\nSecond line.'  # \n means newline
  >>> s  # without print, \n is included in the output
  'First line.\nSecond line.'
  >>> print s  # with print, \n produces a new line
  First line.
  Second line.
  ```

* **character before strings**:
  * **raw** strings: `r'C:\some\name'`('\n' now not means newline)
    ```python
    >>> print 'C:\some\name'  # here \n means newline!
    C:\some
    ame
    >>> print r'C:\some\name'  # note the r before the quote
    C:\some\name
    ```
  * **Unicode** strings: `u'This is a Unicoding\u0020string`
    ```python
    >>> ur'Hello\u0020World !' # It will only apply the above \uXXXX conversion if there is an uneven number of backslashes in front of the small ‘u’
    u'Hello World !'
    >>> ur'Hello\\u0020World !' # The raw mode is most useful when you have to enter lots of backslashes, as can be necessary in regular expressions.
    u'Hello\\\\u0020World !'
     ```

* **multiple lines string**: (In the following examples, the `\` in `"""\` is used to prevent End-of-lines, i.e. `\n`)
  <pre>
  print """\ 
  Usage: thingy [OPTIONS]
       -h                        Display this usage message
       -H hostname               Hostname to connect to
  """
  </pre>

* **string operators**:
  * `+`: Concatenat strings(glued together). Two or more string **literals** next to each other are automatically concatenated.
  * `*`: Repeated strings.
  ```python
  >>> 3 * 'un' + 'ium'
  'unununium'
  >>> # This feature is particularly useful when you want to break long strings
  >>> text = ('Put several strings within parentheses '
          'to have them joined together.')
  ```

* **indexing**: obtain individual characters. the first character having **index 0**. There is **no separate character type**; a character is simply **a string of size one**:
  ```python
  >>> word = 'Python'
  >>> word[0]  # character in position 0
  'P'
  >>> word[5]  # character in position 5
  'n'
  
  ```
  
  Indices may also be negative numbers, to start counting from the right:
  ```python
  >>> word[-1]  # last character
  'n'
  >>> word[-2]  # second-last character
  'o'
  >>> word[-6]
  'P'
  ```

* **slicing**: obtain a substring
  ```python
  >>> word[:] # the value of word
  'Python'
  >>> word[0:2]  # characters from position 0 (included) to 2 (excluded)
  'Py'
  >>> word[:2] + word[2:] # s[:i] + s[i:] is always equal to s
  'Python'
  >>> word[:2]   # character from the beginning to position 2 (excluded)
  'Py'
  >>> word[-2:]  # characters from the second-last (included) to the end
  'on'
  >>> word[4:42] # out of range slice indexes are handled gracefully when used for slicing
  'on'
  ```

* **Immutable**: Python strings cannot be changed
  ```python
  >>> word[0] = 'J'
    ...
  TypeError: 'str' object does not support item assignment
  >>> word[2:] = 'py'
    ...
  TypeError: 'str' object does not support item assignment
  ```

* **Unicode String**:
  * `u` before string:
    ```python
    >>> u"abc"
    'abc'
    ```

  * When a Unicode string is printed, written to a file, or converted with str(), conversion takes place using this default encoding.
    ```python
    >>> str(u"abc")
    'abc'
    >>> str(u"äöü")
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)
    ```
    
  * To convert a Unicode string into an 8-bit string using a specific encoding, Unicode objects provide an encode() method that takes one argument, the name of the encoding. Lowercase names for encodings are preferred.
    
    ```python
    >>> u"äöü".encode('utf-8')
    '\xc3\xa4\xc3\xb6\xc3\xbc'
    ```
    
  * If you have data in a specific encoding and want to produce a corresponding Unicode string from it, you can use the unicode() function with the encoding name as the second argument.
    
    ```python
    >>> unicode('\xc3\xa4\xc3\xb6\xc3\xbc', 'utf-8')
    u'\xe4\xf6\xfc'
    ```


## Lists
* **define**:
  ```python
  >>> squares = [1, 4, 9, 16, 25]
  >>> squares
  [1, 4, 9, 16, 25]
  ```
* **indexing**:
  ```python
  >>> squares[0]  # indexing returns the item
  1
  >>> squares[-1]
  25
  ```

* **slicing**:
  ```python
  >>> squares[:]
  [1, 4, 9, 16, 25]
  >>> squares[-3:]  # slicing returns a new list
  [9, 16, 25]
  ```

* **concatenation**:
  ```python
  >>> squares + [36, 49, 64, 81, 100]
  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
  ```
  
* **mutable**:
  ```python
  >>> cubes = [1, 8, 27, 65, 125]  # something's wrong here
  >>> 4 ** 3  # the cube of 4 is 64, not 65!
  64
  >>> cubes[3] = 64  # replace the wrong value
  >>> cubes
  [1, 8, 27, 64, 125]
  >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  >>> letters
  ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  >>> # replace some values
  >>> letters[2:5] = ['C', 'D', 'E']
  >>> letters
  ['a', 'b', 'C', 'D', 'E', 'f', 'g']
  >>> # now remove them
  >>> letters[2:5] = []
  >>> letters
  ['a', 'b', 'f', 'g']
  >>> # clear the list by replacing all the elements with an empty list
  >>> letters[:] = []
  >>> letters
  []
  ```

* **nest lists**:
  ```python
  >>> a = ['a', 'b', 'c']
  >>> n = [1, 2, 3]
  >>> x = [a, n]
  >>> x
  [['a', 'b', 'c'], [1, 2, 3]]
  >>> x[0]
  ['a', 'b', 'c']
  >>> x[0][1]
  'b'
  ```

* **functions**:
  
  * `len()`:
  
    ```python
    >>> letters = ['a', 'b', 'c', 'd']
    >>> len(letters)
    4
    ```

  * `append()`:
  
    ```python
    >>> cubes.append(216)  # add the cube of 6
    >>> cubes.append(7 ** 3)  # and the cube of 7
    >>> cubes
    [1, 8, 27, 64, 125, 216, 343]
    ```

## 4 Control Flow Statements
* **what is `True`**: like in C, any non-zero integer value is true; zero is false. The condition may also be any sequence: anything with a non-zero length is true, empty sequences are false.
* **multiple assignment**: 
  ```
  a, b=0, 1
  a, b = b, a+b
  ```
  the expressions on the right-hand side are all evaluated first before any of the assignments take place. The right-hand side expressions are evaluated from the left to the right.

* **indentation**: indentation is Python’s way of grouping statements. At the interactive prompt, you have to type a **tab or space(s)** for each indented line. When a compound statement is entered **interactively**, it must be followed by **a blank line** to indicate completion. Note that each line within a basic block must be indented by the **same amount**.
* **standard comparison operators**: ``<`` (less than), ``>`` (greater than), ``==`` (equal to), ``<=`` (less than or equal to), ``>=`` (greater than or equal to) and ``!=`` (not equal to)

### 4.1 `if` Statements
```
>>> x = int(raw_input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print 'Negative changed to zero'
... elif x == 0:
...     print 'Zero'
... elif x == 1:
...     print 'Single'
... else:
...     print 'More'
...
More
```
An `if … elif … elif …` sequence is a **substitute for the switch or case statements** found in other languages.

### 4.2 `for` Statements
Python’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence:

```
>>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print w, len(w)
...
cat 3
window 6
defenestrate 12
```

If you need to modify the sequence you are iterating over while inside the loop, it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy: 

```
>>> for w in words[:]:  # Loop over a slice copy of the entire list.
...     if len(w) > 6:
...         words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
```

### 4.3 `while` Statements
```
>>> a, b = 0, 1
>>> while b < 1000:
...     print b, # A trailing comma avoids the newline after the output
...     a, b = b, a+b
...
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
```

### 4.4 `break`, `continue` and `else` in Loops
* `break`: Like in `C`, breaks out of the innermost enclosing `for` or `while` loop.
* `continue`: Like in `C`, continues with the next iteration of the loop:
* `else`: codes in this block are excuted in the following situations:
  * the loop terminates through exhaustion of the list (with `for`) 
  * the condition becomes false (with `while`)

  but **not when the loop is terminated by a break statement**.

```
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print n, 'equals', x, '*', n/x
...             break
...     else: # the else clause belongs to the for loop, not the if statement
...         # loop fell through without finding a factor
...         print n, 'is a prime number'
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
```
