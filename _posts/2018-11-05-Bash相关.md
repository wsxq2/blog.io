---
tags: [Bash,TODO]
last_modified_time: 2019-04-21 18:49:45 +0800
---

关于 Shell 的系统学习可参考这个网站：[The Linux Command Line 中文版](https://www.kancloud.cn/thinkphp/linux-command-line/39431)

<p id="markdown-toc"></p>
<!-- vim-markdown-toc GFM -->

* [bash 自动补全](#bash-自动补全)
* [Expansion](#expansion)
* [整数运算](#整数运算)
  * [`$(())`](#)
  * [`expr`](#expr)
* [浮点运算](#浮点运算)
  * [`bc`](#bc)
  * [`awk`](#awk)
* [拼接字符串](#拼接字符串)
  * [使用 `""`](#使用-)
  * [使用 `+=`](#使用--1)
  * [使用 `printf`](#使用-printf)
* [从文件或`stdin`中读取输入](#从文件或stdin中读取输入)
* [转换相对路径为绝对路径](#转换相对路径为绝对路径)
  * [`$PWD`](#pwd)
  * [`realpath`](#realpath)
* [字符串匹配通配符](#字符串匹配通配符)
  * [`=`](#-1)
  * [`case..in..`](#casein)
* [字符串匹配正则表达式](#字符串匹配正则表达式)
  * [`=~`](#-2)
  * [`expr match`](#expr-match)
* [实践记录](#实践记录)
  * [处理缩略语](#处理缩略语)
    * [使用`grep`](#使用grep)
    * [使用`case..in..`](#使用casein)
    * [使用`=~`](#使用)
    * [使用`=`](#使用-1)
* [链接](#链接)

<!-- vim-markdown-toc -->

## bash 自动补全

```
yum install bash-completion -y
```

## Expansion
如果想了解一些基本的 Shell Expansion（如通配符，`~`，数学运算，`{}`拓展，`$variable`引用，`$()`，单引号，双引号，转义字符，反斜杠），可以参考如下文章

[Expansion](http://linuxcommand.org/lc3_lts0080.php)

## 整数运算
### `$(())`
   ```
   $ echo "$((5*5+5-3/2))"
   29
   ```
### `expr`
   ```
   $ expr 5 - 4
   1
   ```

## 浮点运算
### `bc`
   ```
   $ echo "5.01-4*2.0"|bc
   -2.99
   ```
### `awk`
   ```
   $ awk 'BEGIN{print 7.01*5-4.01}'
   31.04
   ```

## 拼接字符串
本部分内容参考自 [shell - How to concatenate string variables in Bash - Stack Overflow](https://stackoverflow.com/questions/4181703/how-to-concatenate-string-variables-in-bash)

### 使用 `""`
```
$ foo="Hello"
$ foo="$foo World"
$ echo $foo
Hello World
$ a='hello'
$ b='world'
$ c="$a$b"
$ echo $c
helloworld
```

### 使用 `+=`
```
$ A="X Y"
$ A+=" Z"
$ echo "$A"
X Y Z
$ a=2
$ a+=4
$ echo $a
24
```

### 使用 `printf`
```
$ foo="Hello"
$ printf -v foo "%s World" $foo
$ echo $foo
Hello World
```

## 从文件或`stdin`中读取输入
```
while read line
do
  echo "$line"
done < "${1:-/dev/stdin}"
```
以上脚本实现：执行该脚本时将第一个参数视为文件名，从该文件中读取输入；如果没有传入参数，则从`/dev/stdin`（即标准输入读取输入）

`${1:-/dev/stdin}`根据条件执行替换，即如果`$1`（传入脚本的第一个参数）不存在则由`/dev/stdin`替换。

详情参见 [How to read from a file or stdin in Bash? - Stack Overflow](https://stackoverflow.com/questions/6980090/how-to-read-from-a-file-or-stdin-in-bash)

## 转换相对路径为绝对路径
本部分参考自 [shell - Bash: retrieve absolute path given relative - Stack Overflow](https://stackoverflow.com/questions/4175264/bash-retrieve-absolute-path-given-relative/31605674)

```
relative_path="../../program/py/hack/get_host.sh"
```

### `$PWD`
```
echo "$PWD/$relative_path"
```

### `realpath`
```
echo `realpath $relative_path`
```

## 字符串匹配通配符
### `=`
参见 [使用`=`](#使用-1)

### `case..in..`
参见 [使用`case..in..`](#使用casein)

## 字符串匹配正则表达式
该部分参考自 [Check if a string matches a regex in Bash script - Stack Overflow](https://stackoverflow.com/questions/21112707/check-if-a-string-matches-a-regex-in-bash-script)

### `=~`
```
[[ $date =~ ^[0-9]{8}$ ]] && echo "yes"
```

### `expr match`
```
expr match "$date" "^[0-9]\{8\}" >/dev/null && echo yes
```

## 实践记录
### 处理缩略语
问题详情参见 [Sed使用笔记 - 处理缩略语](http://master:8888/blog/2019/04/20/sed%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/#%E5%A4%84%E7%90%86%E7%BC%A9%E7%95%A5%E8%AF%AD)

#### 使用`grep`
```
temp=$IFS
IFS=
while read line
do
	tmp=$(grep -h "^\*\[$line\]" abbreviations.txt)
	if [[ -z $tmp ]]; then
		tmp="*[$line]: "
	fi
	echo $tmp
done < "${1:-/dev/stdin}"
IFS=$temp
```
注意`$()`命令需要修改`IFS`以保证`$tmp`变量不会丢失换行符，详情参见：
[shell - Why do newline characters get lost when using command substitution? - Unix & Linux Stack Exchange](https://unix.stackexchange.com/questions/164508/why-do-newline-characters-get-lost-when-using-command-substitution#answer-164548)

#### 使用`case..in..`
```
while read word
do
	tmp=
	while read abbr
	do
		glob="\*\[$word\]:*"
		case $abbr in
			 $glob )
				if [[ $tmp ]]; then
					tmp="$tmp\n$abbr";
				else
					tmp=$abbr;
				fi
				;;
		esac
	done < abbreviations.txt
	if [[ -z $tmp ]]; then
		tmp="*[$word]: "
	fi
	echo -e $tmp
done < "${1:-/dev/stdin}"
```

#### 使用`=~`
```
while read word
do
	tmp=
	while read abbr
	do
		regex="^\*\[$word]:.*\$"
		if [[ $abbr =~ $regex ]]; then
			if [[ $tmp ]]; then
				tmp="$tmp\n$abbr";
			else
				tmp=$abbr;
			fi
		fi
	done < abbreviations.txt
	if [[ -z $tmp ]]; then
		tmp="*[$word]: "
	fi
	echo -e $tmp
done < "${1:-/dev/stdin}"
```

#### 使用`=`
```
while read word
do
	tmp=
	while read abbr
	do
		glob="\*\[$word\]:*"
		if [[ $abbr = $glob ]]; then
			if [[ $tmp ]]; then
				tmp="$tmp\n$abbr";
			else
				tmp=$abbr;
			fi
		fi
	done < abbreviations.txt
	if [[ -z $tmp ]]; then
		tmp="*[$word]: "
	fi
	echo -e $tmp
done < "${1:-/dev/stdin}"
```



## 链接
下面总结了本文中使用的所有链接：

<!-- link start -->

* [How to read from a file or stdin in Bash? - Stack Overflow](https://stackoverflow.com/questions/6980090/how-to-read-from-a-file-or-stdin-in-bash)
* [Sed使用笔记 - 处理缩略语](http://master:8888/blog/2019/04/20/sed%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/#%E5%A4%84%E7%90%86%E7%BC%A9%E7%95%A5%E8%AF%AD)
* [The Linux Command Line 中文版](https://www.kancloud.cn/thinkphp/linux-command-line/39431)
* [shell - Bash: retrieve absolute path given relative - Stack Overflow](https://stackoverflow.com/questions/4175264/bash-retrieve-absolute-path-given-relative/31605674)
* [shell - How to concatenate string variables in Bash - Stack Overflow](https://stackoverflow.com/questions/4181703/how-to-concatenate-string-variables-in-bash)
<!-- link end -->




