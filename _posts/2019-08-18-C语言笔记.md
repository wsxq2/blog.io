---
tags: [C语言]
last_modified_time: 2019-08-24 16:29:25 +0800
---

本文是笔者使用 C 语言编写程序的笔记

<p id="markdown-toc"></p>
<!-- vim-markdown-toc GFM -->

* [Linux 中的 C 语言文档支持](#linux-中的-c-语言文档支持)
* [常用函数](#常用函数)
* [遇到过的问题](#遇到过的问题)
  * [如何定义常量？](#如何定义常量)
  * [如何判断操作系统采用的是大端储存还是小端存储?](#如何判断操作系统采用的是大端储存还是小端存储)
  * [What is the maximum size of an array in C?](#what-is-the-maximum-size-of-an-array-in-c)
  * [print in binary format?](#print-in-binary-format)
  * [如何从函数返回数组？](#如何从函数返回数组)
    * [一、使用指针（推荐）](#一使用指针推荐)
    * [二、使用结构体](#二使用结构体)
  * [static 有什么用？](#static-有什么用)
* [趣事](#趣事)
  * [国际 C 语言混乱代码大赛（IOCCC)](#国际-c-语言混乱代码大赛ioccc)
* [链接](#链接)

<!-- vim-markdown-toc -->

## Linux 中的 C 语言文档支持
由于 Linux 是由 C 语言写的，所以其对 C 语言的支持非常友好。比如其`man`手册中包含了大量**系统调用**函数和**标准函数**。下面对这部分内容作详细说明

Linux 中查看 C 语言中某个函数的文档：

```
man 2|3 FUNCTION
```

例如：

```
man 3 printf
man 3 malloc
man 2 open
man 3 fopen
man 2 read
man 3 fread
man 2 fork
...
```

如果需要查看某个命令有多少个页面，可以使用参数`-aw`，例如：

```
root@master:_posts# man -aw printf
/usr/share/man/man1/printf.1.gz
/usr/share/man/man1p/printf.1p.gz
/usr/share/man/man3/printf.3.gz
/usr/share/man/man3p/printf.3p.gz
root@master:_posts#
```

其中页面编号的含义：

> * 1   Executable programs or shell commands
> * **2   System calls (functions provided by the kernel)**
> * **3   Library calls (functions within program libraries)**
> * 4   Special files (usually found in /dev)
> * 5   File formats and conventions eg /etc/passwd
> * 6   Games
> * 7   Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)
> * 8   System administration commands (usually only for root)
> * 9   Kernel routines [Non standard]
> 
> ——引用自`man man`

## 常用函数
这部分是笔者在使用 C 语言编程的过程，总结的时常需要使用但又总是记不住的函数。分为**标准库函数**和**Linux系统调用**两部分

**标准库函数**：

| 函数名    | 所在头文件 | 用法                                                                             |
|-----------|------------|----------------------------------------------------------------------------------|
| malloc    | stdlib.h   | `void *malloc(size_t size);`                                                     |
| free      | stdlib.h   | `void free(void *ptr);`                                                          |
| memcpy    | string.h   | `void *memcpy(void *dest, const void *src, size_t n);`                           |
| srand     | stdlib.h   | `void srand(unsigned int seed);`                                                 |
| rand      | stdlib.h   | `int rand(void);`                                                                |
| fopen     | stdio.h    | `FILE *fopen(const char *path, const char *mode);`                               |
| fread     | stdio.h    | `size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`              |
| fwrite    | stdio.h    | `size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);`       |
| fclose    | stdio.h    | `int fclose(FILE *fp);`                                                          |
| localtime | time.h     | `struct tm *localtime(const time_t *timep);`                                     |
| clock     | time.h     | `clock_t clock(void);`                                                           |
| strftime  | time.h     | `size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);` |


**Linux 系统调用**：

| 函数名    | 所在头文件   | 用法                                            |
|-----------|--------------|-------------------------------------------------|
| time      | time.h       | time_t time(time_t *t);                         |
| fork      | unistd.h     | pid_t fork(void);                               |
| socket    | sys/socket.h | int socket(int domain, int type, int protocol); |


对于**标准库函数**可以使用`man 3 FUNCTION`查看该函数的更多信息，例如：

```
man 3 malloc
man 3 memcpy
```

对于**Linux 系统调用**可以使用`man 2 FUNCTION`查看该函数的更多信息，例如：

```
man 2 time
man 2 fork
```

更多获取帮助的相关内容参见 [Linux 中的 C 语言文档支持](#linux-中的-c-语言文档支持)

## 遇到过的问题
### 如何定义常量？

```
#define PI 3.1415926f
const float pi 3.1415926f;
```

### 如何判断操作系统采用的是大端储存还是小端存储?

```c
#include <stdio.h>

int main() {
  int x = 0x12345678; /* 305419896 */
  unsigned char *p = (char *)&x;
  printf("%0x %0x %0x %0x\n", p[0], p[1], p[2], p[3]);
  return 0;
}
```

### What is the maximum size of an array in C?
> There is no fixed limit to the size of an array in C.
> 
> ——引用自 [What is the maximum size of an array in C? - Stack Overflow](https://stackoverflow.com/questions/9386979/what-is-the-maximum-size-of-an-array-in-c)

但是 Bash 本身通常限制了一些大小（如下是 CentOS 7.2 上的默认设置）：
```bash
# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 15075
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 15075
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```
其中比较重要的是如下几个：

* **core file size**：执行程序出现**Segmentation fault**错误时输出的 core 文件的大小。如果设置为 0 （0 为默认值），则不会输出 core 文件
* **stack size**：程序运行过程中可以使用的最大栈内存的大小。如果设置太小（比如默认的 8192 KB），则你执行程序时很容易出现 **Segmentation fault** 错误，尤其是你在程序中声明了较大数组（静态数组例外）或较深层次的递归的情况下

另外需要注意的是`ulimit`是 Bash 内置命令，所以不能使用`ulimit --help`来获取相应的帮助，而应使用`help ulimit`命令

### print in binary format?
> The printf() family is only able to print in base 8, 10, and 16 using the standard specifiers directly. I suggest creating a function that converts the number to a string per code's particular needs.

Quick and easy solution:

```
void printbits(my_integer_type x)
{
    for(int i=sizeof(x)<<3; i; i--)
        putchar('0'+((x>>(i-1))&1));
}
```

Greatest:

```
#define TO_BASE_N (sizeof(unsigned)*CHAR_BIT + 1)

//                               v. compound literal .v
#define TO_BASE(x, b) my_to_base((char [TO_BASE_N]){""}, (x), (b))

// Tailor the details of the conversion function as needed
// This one does not display unneeded leading zeros
// Use return value, not `buf`
char *my_to_base(char *buf, unsigned i, int base) {
  assert(base >= 2 && base <= 36);
  char *s = &buf[TO_BASE_N - 1];
  *s = '\0';
  do {
    s--;
    *s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i % base];
    i /= base;
  } while (i);

  // Could employ memmove here to move the used buffer to the beginning

  return s;
}
```

以上内容来自 [c - Is there a printf converter to print in binary format? - Stack Overflow](https://stackoverflow.com/questions/111928/is-there-a-printf-converter-to-print-in-binary-format)

### 如何从函数返回数组？

**版权相关**：本部分内容修改自[【原】C语言函数返回数组的问题](https://www.cnblogs.com/wuqi1003/archive/2013/01/09/2853657.html)

有些时候需要子函数将一个数组返回出来，通常是两种方法，一种是靠**指针**，另一种是**结构体**。

#### 一、使用指针（推荐）
1. 对于 char 数组可以直接使用`char*`：

   ```
   #include <stdio.h>
   
   char *test()
   {
       //char tmp[30]="第一个测试例子\n";//写成这样编译时弹出警告，最后的结果也是乱码
       char *tmp="第一个测试例子";//写成这样可以用指针返回数组首地址
       return tmp;
   }
   
   void main(void)
   {
       printf("%s",test());
   }
   ```
   
   **解释**：之所以`*tmp`可以而`tmp[30]`不可以，是因为`tmp[30]`是个局部变量，子函数结束时该数组地址虽然没变，但是里面的值已经无意义了，而`*tmp`是定义了一个全局变量。

2. 对于普通数组，可以使用`static`这个关键字（也可使用`malloc`函数，如果数组大小是个变量而非常量的话）：

   ```
   #include <stdio.h>
   
   char *test()
   {
       static char tmp[30]="第二个测试例子";
       return tmp;
   }
   
   void main(void)
   {
       printf("%s",test());
   }
   ```
   
   **解释**：在数组`tmp[30]`前面加入了`static`关键字,它就使得`tmp[30]`存放在内存中的静态存储区中,所占用的存储单元一直不释放直到整个程序运行结束.所以当主函数调用完`print()`函数后,该空间依然存在.所以`main()`函数中获得首地值后可以访问数组中的元素.
   
#### 二、使用结构体

```
#include <stdio.h>
#include <string.h>

struct ret
{
    char buf[100];
};//定义结构体时不要忘了分号

struct ret test(char *tmp)
{
    struct ret a;
    strcpy(a.buf,tmp);
    return a;
}


int main()
{
    struct ret b;
    b=test("用结构体作为返回值传递数组");
    printf("%s\n",b.buf);
    return 0;
}
```

数组之间的赋值不能直接赋值，即不要直接将数组A赋给数组B，而是要用`strcpy`（**字符型数组**）或者`memcpy`（**非字符型数组**）；而结构体可以直接赋值

此外，如果上面的代码中的结构体 ret 中的成员变量 buf 的大小较小的话，将会导致意外错误，笔者遇到了两种 Bus error 和 Segmentation fault

### static 有什么用？
1. **隐藏**： 当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
2. **持久**: 保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围。
3. **默认初始化为0**: 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。

总结：首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。

参考链接： [static的作用](https://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html)

## 趣事
### 国际 C 语言混乱代码大赛（IOCCC)
官网： [The International Obfuscated C Code Contest](https://www.ioccc.org/)
维基百科：
[国际C语言混乱代码大赛 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85C%E8%AF%AD%E8%A8%80%E6%B7%B7%E4%B9%B1%E4%BB%A3%E7%A0%81%E5%A4%A7%E8%B5%9B)

## 链接
下面总结了本文中使用的所有链接：

<!-- link start -->

<!-- link end -->

<!-- abbreviations start -->

<!-- abbreviations end -->
